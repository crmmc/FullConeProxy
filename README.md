尝试自己造个轮子，主要是为了熟悉 Go 语言，做点东西
当然有更好的项目，他们拥有更好的密码学安全性，拥有更强劲的性能，更好的优化，所以这个并不适合部署在生产环境使用，我自己主力都不用这个(划掉)
但是他让我明白原理，让我有机会实践且应用我自己的想法，我还可以根据自己的需要定制化连接的特点，自己 选择和规划伪装方式

警告： 此项目仅用于技术交流与学习，禁止用于任何违规违法用途！！！ 作者不承担任何任何一点责任

源代码可以随意使用，不作任何限制，但是程序使用了"github.com/klauspost/pgzip"第三方可并行 gzip 压缩库实现数据压缩功能，
这部分代码任何权利均归原作者所有

FullConeProxy
An Private Proxy Tool

Usage of FullConeProxy:
-c
加上这个参数才能运行 LOCAL 模式
-r string
仅适用于 LOCAL 模式的，设置远程服务器地址和端口，可以同时使用多个服务器。每个服务器地址用逗号分隔。服务器访问密码的顺序必须与服务器地址相对应，密码字符串也用逗号分隔(默认 :127.0.0.1:10010")
-s string
仅用于服务器模式，设置服务器本地侦听地址和端口，默认为 (127.0.0.1:10010)
-k string
密钥字符串，服务器密码顺序必须对应于服务器地址顺序，密码之间用逗号分隔，在服务器模式下，仅使用第一个密码(默认为"TESTMEBABY")
-norandom
决定选择服务器的方式，默认情况下，有多个服务器可用的时候每次连接都会随机选择一个服务器使用，但如果开启此开关，靠前的服务器的优先级高于
靠后的服务器的优先级，这将导致，靠后的服务器只有在靠前的服务期无法使用的时候才会拿出来使用，相当于添加的服务器作为备份服务器，我并没有
添加服务器淘汰机制，所以增加了服务器连接失败的提示，需要靠人工筛选掉已经无法使用的服务器
-tcptimeout int
设置 TCP 读超时，不应低于 UDP 超时（默认为 30）
-udptimeout int
设置 UDP 超时，应大于 TCP 超时（默认为 150）
-debug  
 启用 Debug，显示调试信息
-h  
 显示帮助
-l string
只能在 Local 模式下使用，用于设置 Socks5 监听地址 [::]:10805 (默认 "[::]:10805")
-lower
使用较低安全性的加密方法（AES-128-GCM）而不是 AES-256-GCM，此选项将影响所有密码的加密。使用多台服务器时，请注意，无法自定义每个服务器使用的密码加密模式
-test
在测试模式下，将在一台计算机上运行服务器和客户端

关于程序原理：

简单的指令包的结构
+---------------+--------------+--------------+----------+----------+
| Session ID | Control Code | Address Type | DST.ADDR | DST.PORT |
+---------------+--------------+--------------+----------+----------+
| 16 byte | 1 byte | 1 byte | Variable | 2 byte |
+---------------+--------------+--------------+----------+----------+
Session 由客户端生成的唯一随机数,16 字节，由客户端定义，作为会话 ID 使用
Control Code 与 socks5 相同的控制代码
Address Type 与 socks5 相同的地址类型
DST.ADDR 与 socks5 相同的地址
DST.PORT 与 socks5 相同的端口

在 LOCAL 到 SERVER 传输过程中使用的是不可信信道，所以必须加密

这是一个数据帧,playload 为加密后的数据
+----------------+-----------+
| payload length | playload |
+----------------+-----------+
| 4 byte | variable |
+----------------+-----------+
Server 会收集满一整个数据帧后进行处理,验证失败会直接断开连接

每一个加密数据加密前的格式
+------------------+-----------+--------+
|Random Data length|Random Data|RealData|
+------------------+-----------+--------+
| 1 byte | variable |variable|
+------------------+-----------+--------+
由更底层的 AES GCM 加密保障消息的机密性与可靠性,所以在这一层接收到的消息可以认为是无误且可信的，但是为了防止针对流加密的统计学方法攻击
预测 ATYPE，将固定的 ATYPE 改成了范围内的随机数，在每一个数据包头前加随机数据防止针对 UDP 包的利用,在数据包前添加了随机长度的随机数据填充以应对针对特定字节的统计学攻击，双管齐下

抗重放：
客户端发起连接服务器的首个数据包，由秘钥加时间戳的 MD5 通过 HASH 函数共同通过
AES - GCM 加密方式加密，每个包都有其独特的包 ID，也就是包头的 16 byte 随机数，允许服务器和客户端的时间差为正负两秒之内

自己写了一个 FIFO 的链表，服务器首次收到连接都会校验包 ID 是否在这个链表里，在这个链表里就证明一分钟内曾使用过这个 ID
为了防止数组会越来越大，占用内存不说，每次接受连接时遍历数组会越来越困难，开个 goruntime 检查每个 包 ID 的生存周期，过期的包会被删除
若是超过 15 秒的话就删除，此时因为存在首包使用时间戳加密的缘故，正负10秒以外的包将不会被服务器接受，所以这个方案可行

采用 FIFO 链表的原因是，这样检测包生存周期的 func，仅需要检查首个数据的生存周期，如果它没过期，那后续包不可能过期，
如果其过期那就删除后检测下一个包（此时其成为新的“首个数据”）,还是过期的话继续删除，重复这一操作，
这样的话就不需要检查生存周期时遍历整个链表了，但是检查这个数据是否已存在于链表中，依然需要遍历整个链表

应对本地 echo 重放攻击：
Client 的加密数据包有自己的标识，用 GCM 加密方式的 A 的 ADD Data 部分标识 0XFF,0XFF
Server 的加密数据包有自己的标识，用 GCM 加密方式的 A 的 ADD Data 部分标识 0XFC,0XFF

应对交换顺序的 TCP 包重放:
只能用增加包 ID 来解决，包 ID 从零开始递增，用 uint32，4byte 表示


仍然存在的 bug：
被恶意的交换数据包顺序客户端与服务端也不能分辨出来。
可能被大规模的流量分析发现特征，毕竟这是个未知的加密流量，所以我打算伪装成 FTP，然后客户端和服务端握手完全遵守 FTP 的规范，这样就不会被发现里，就算流量被 Dump，那也是以“文件”的形式被 Dump 下来

尚未实现的目标：
1: 伪装 FTP(但是似乎不是很好的选择，而伪装 http、https 不如用造好的轮子，
2: 为加密数据增加包 ID，用于防止 MITM 的交换包顺序重放

更新日志
V1.0.0:
完成大体框架，跑得起来的程度
V1.1.0:
重大更新，重新精炼了代码，加入了抗重放的功能
V1.2.0:
修 bug，增加了服务器负载均衡的功能，支持多服务器，支持选择 AES GCM 加密方式的密码位数（128 位，256 位）
V1.2.2:
修复了负载均衡的 bug，改善了抗重放的逻辑，安全性提升
V1.2.4：
加入 Gzip 压缩数据，是否真的有用呢？还是单纯在耗费 CPU 性能呢？？ 调整默认允许的数据包收发两段时间差值到 10 秒，把 nonceGC 运行间隔设置成 15 秒
V1.2.5:
更改使用的官方 gzip 库为第三方的 github.com/klauspost/pgzip 库，因为这个库大幅优化了 gzip 的压缩效率，go 官方 gzip 实现相比之下太慢力！
V1.2.6:
删除 gzip 压缩方法，无论使用哪个库，都会使 CPU 占用率大幅提升，而速度大幅降低，在我的平台上，开启 gzip 后 CPU 占用率从 4%上升到 24%，但是速度却从 240Mbps 降到了 30Mbps，匪夷所思。
V1.2.7:
更新了更多的抗中间人，抗协议分析的过程，吸收了很多前人的经验，更改了加密数据承载的格式，增加了对逐字节重放的防御，优化了对重放的判断逻辑，话说部署测试时真的收到重放数据包了诶
V1.2.9 bate:
犯了和酸酸 OTA 作者同样的错误，想要使用 Encrypt-and-MAC (E&M) ，MAC-then-Encrypt (MtE) <- 即 OTA 的做法,这是很不安全
的，而且引入被精准探测的漏洞，应该全程使用 Encrypt-then-MAC (EtM). 增加了个反击开关，在代码里硬编码，默认关闭，我想见识
一下这个方法会不会引起它的反击呢
