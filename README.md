尝试自己造个轮子，主要是为了熟悉 Go 语言，做点东西
当然有更好的项目，他们拥有更好的密码学安全性，拥有更强劲的性能，更好的优化，所以这个病不是和部署在生产环境使用，我自己主力都不用这个
但是他让我明白原理，让我有机会实践且应用我自己的想法，我还可以根据自己的需要定制化连接的特点，自己 选择和规划伪装方式

警告： 此项目仅用于技术交流与学习，禁止用于任何违规违法用途！！！ 作者不承担任何任何一点责任

源代码可以随意使用，不作任何限制

关于程序：

首先有一组预共享密钥，16byte 数据,由当前的时间 （精确到分钟）生成,作为首包的附加验证数据
但是有个缺陷,就是服务端可客户端的时间差会导致有可能出现一段时间无法发起新连接的 BUG，因为例如服务段时间与客户端时间相差 2 秒，那
当服务器时间是 1:59:58 的时候,客户端时间已经 2:00:00 了，就会导致客户端这时候发起的新连接服务端全部拒绝，
因为首个包的附加数据是本地时间的分钟的字符串通过 MD5 生成的，所以这两秒会无法使用服务器

这个方法好像也不能防止很迅速的重放攻击，有待优化和解决，V2 的那个一直生成随机数的方法感觉有点搞笑，不想这样做

+---------------+--------------+--------------+----------+----------+
| Random Number | Control Code | Address Type | DST.ADDR | DST.PORT |
+---------------+--------------+--------------+----------+----------+
| 16 byte | 1 byte | 1 byte | Variable | 2 byte |
+---------------+--------------+--------------+----------+----------+
Random Number 由客户端生成的唯一随机数,16 字节，由客户端定义，作为后续数据的附加数据使用
Control Code 与 socks5 相同的控制代码
Address Type 与 socks5 相同的地址类型
DST.ADDR 与 socks5 相同的地址
DST.PORT 与 socks5 相同的端口

Client 将这组数据用与共享密钥加密成以下样式，防止粘包
+--------+----------------+
| size | Payload |
---------+----------------+
| 4 byte | Variable |
+--------+----------------+

Server 收到数据,首先校验 Encrypted Data 的 size,收集满后进行下一步操作

未实现的想法：

抗重放：
拿个全局数组，服务器首次收到连接都会校验 random number 是否在这个数组里，在的话就是重放，
挂起连接（自己的服务器连接资源多的话，就 keeplive 然后挂在那里），不在的话就接受连接并将
random number 放进这个数组。

为了防止数组会越来越大，占用内存不说，每次接受连接时遍历数组会越来越困难，开个 goruntime 检查每个 ramdon number 的生存周期，
若是超过一分钟的话就删除，此时因为存在首包使用时间戳加密的缘故，一分钟后的包将不被服务器接受！
