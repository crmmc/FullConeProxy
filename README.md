尝试自己造个轮子，主要是为了熟悉 Go 语言，做点东西
当然有更好的项目，他们拥有更好的密码学安全性，拥有更强劲的性能，更好的优化，所以这个并不适合部署在生产环境使用，我自己主力都不用这个(划掉)
但是他让我明白原理，让我有机会实践且应用我自己的想法，我还可以根据自己的需要定制化连接的特点，自己 选择和规划伪装方式

警告： 此项目仅用于技术交流与学习，禁止用于任何违规违法用途！！！ 作者不承担任何任何一点责任

源代码可以随意使用，不作任何限制，但是程序使用了"github.com/klauspost/pgzip"第三方可并行gzip压缩库实现数据压缩功能，
这部分代码任何权利均归原作者所有

FullConeProxy
An Private Proxy Tool

Usage of FullConeProxy:
    -c 
        加上这个参数才能运行LOCAL模式
    -r string
        仅适用于LOCAL模式的，设置远程服务器地址和端口，可以同时使用多个服务器。每个服务器地址用逗号分隔。服务器访问密码的顺序必须与服务器地址相对应，密码字符串也用逗号分隔(默认 :127.0.0.1:10010")
    -s string
        仅用于服务器模式，设置服务器本地侦听地址和端口，默认为 (127.0.0.1:10010)
    -k string
        密钥字符串，服务器密码顺序必须对应于服务器地址顺序，密码之间用逗号分隔，在服务器模式下，仅使用第一个密码(默认为"TESTMEBABY")
    -norandom
        决定选择服务器的方式，默认情况下，有多个服务器可用的时候每次连接都会随机选择一个服务器使用，但如果开启此开关，靠前的服务器的优先级高于
        靠后的服务器的优先级，这将导致，靠后的服务器只有在靠前的服务期无法使用的时候才会拿出来使用，相当于添加的服务器作为备份服务器，我并没有
        添加服务器淘汰机制，所以增加了服务器连接失败的提示，需要靠人工筛选掉已经无法使用的服务器
    -tcptimeout int
        设置TCP读超时，不应低于UDP超时（默认为30）
    -udptimeout int
        设置UDP超时，应大于TCP超时（默认为150）
    -debug  
        启用Debug，显示调试信息
    -h 显示帮助
    -l string 
        只能在Local模式下使用，用于设置Socks5监听地址 [::]:10805 (默认 "[::]:10805")
    -lower
        使用较低安全性的加密方法（AES-128-GCM）而不是AES-256-GCM，此选项将影响所有密码的加密。使用多台服务器时，请注意，无法自定义每个服务器使用的密码加密模式
    -gzip
        开启Gzip压缩数据以节省流量，这可能增加机器的负担并降低流量响应速度(一般来说可以忽略不计的延迟增加，但是不可忽略的CPU占用增加)
    -test
        在测试模式下，将在一台计算机上运行服务器和客户端

关于程序原理：

简单的指令包的结构
+---------------+--------------+--------------+----------+----------+
| Session ID | Control Code | Address Type | DST.ADDR | DST.PORT |
+---------------+--------------+--------------+----------+----------+
| 16 byte | 1 byte | 1 byte | Variable | 2 byte |
+---------------+--------------+--------------+----------+----------+
Session 由客户端生成的唯一随机数,16 字节，由客户端定义，作为会话 ID 使用
Control Code 与 socks5 相同的控制代码
Address Type 与 socks5 相同的地址类型
DST.ADDR 与 socks5 相同的地址
DST.PORT 与 socks5 相同的端口



防止粘包的简单 TCP 包格式，这是一个数据帧
+--------+----------------+
| size | Payload |
---------+----------------+
| 4 byte | Variable |
+--------+----------------+
Server 会收集满一整个数据帧后进行处理


抗重放：
客户端发起连接服务器的首个数据包，由秘钥加时间戳的MD5通过 HASH 函数共同通过
AES - GCM 加密方式加密，每个包都有其独特的包 ID，也就是包头的 16 byte 随机数，允许服务器和客户端的时间差为正负两秒之内

自己写了一个 FIFO 的链表，服务器首次收到连接都会校验包 ID 是否在这个链表里，在这个链表里就证明一分钟内曾使用过这个 ID
为了防止数组会越来越大，占用内存不说，每次接受连接时遍历数组会越来越困难，开个 goruntime 检查每个 包 ID 的生存周期，过期的包会被删除
若是超过5秒的话就删除，此时因为存在首包使用时间戳加密的缘故，正负两秒以外的包将不会被服务器接受，所以这个方案可行

采用 FIFO 链表的原因是，这样检测包生存周期的 func，仅需要检查首个数据的生存周期，如果它没过期，那后续包不可能过期，
如果其过期那就删除后检测下一个包（此时其成为新的“首个数据”）,还是过期的话继续删除，重复这一操作，
这样的话就不需要检查生存周期时遍历整个链表了，但是检查这个数据是否已存在于链表中，依然需要遍历整个链表


更新日志
V1.0.0:
    完成大体框架，跑得起来的程度
V1.1.0:
    重大更新，重新精炼了代码，加入了抗重放的功能
V1.2.0:
    修bug，增加了服务器负载均衡的功能，支持多服务器，支持选择AES GCM加密方式的密码位数（128位，256位）
V1.2.2:
    修复了负载均衡的bug，改善了抗重放的逻辑，安全性提升
V1.2.4：
    加入Gzip压缩数据，是否真的有用呢？还是单纯在耗费CPU性能呢？？ 调整默认允许的数据包收发两段时间差值到10秒，把nonceGC运行间隔设置成15秒
V1.2.5:
    更改使用的官方gzip库为第三方的github.com/klauspost/pgzip库，因为这个库大幅优化了gzip的压缩效率，go官方gzip实现相比之下太慢力！
V1.2.6 Stable
    删除gzip压缩方法，无论使用哪个库，都会使CPU占用率大幅提升，而速度大幅降低，在我的平台上，开启gzip后CPU占用率从4%上升到24%，但是速度却从240Mbps降到了30Mbps，匪夷所思。