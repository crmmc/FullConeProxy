尝试自己造个轮子，主要是为了熟悉 Go 语言，做点东西
当然有更好的项目，他们拥有更好的密码学安全性，拥有更强劲的性能，更好的优化，所以这个并不适合部署在生产环境使用，我自己主力都不用这个(划掉)
但是他让我明白原理，让我有机会实践且应用我自己的想法，我还可以根据自己的需要定制化连接的特点，自己 选择和规划伪装方式

警告： 此项目仅用于技术交流与学习，禁止用于任何违规违法用途！！！ 作者不承担任何任何一点责任

源代码可以随意使用，不作任何限制，但是程序使用了"github.com/klauspost/pgzip"第三方可并行gzip压缩库实现数据压缩功能，
这部分代码任何权利均归原作者所有

FullConeProxy
An Private Proxy Tool

Usage of FullConeProxy:
    -c 
        加上这个参数才能运行LOCAL模式
    -r string
        仅适用于LOCAL模式的，设置远程服务器地址和端口，可以同时使用多个服务器。每个服务器地址用逗号分隔。服务器访问密码的顺序必须与服务器地址相对应，密码字符串也用逗号分隔(默认 :127.0.0.1:10010")
    -s string
        仅用于服务器模式，设置服务器本地侦听地址和端口，默认为 (127.0.0.1:10010)
    -k string
        密钥字符串，服务器密码顺序必须对应于服务器地址顺序，密码之间用逗号分隔，在服务器模式下，仅使用第一个密码(默认为"TESTMEBABY")
    -norandom
        决定选择服务器的方式，默认情况下，有多个服务器可用的时候每次连接都会随机选择一个服务器使用，但如果开启此开关，靠前的服务器的优先级高于
        靠后的服务器的优先级，这将导致，靠后的服务器只有在靠前的服务期无法使用的时候才会拿出来使用，相当于添加的服务器作为备份服务器，我并没有
        添加服务器淘汰机制，所以增加了服务器连接失败的提示，需要靠人工筛选掉已经无法使用的服务器
    -tcptimeout int
        设置TCP读超时，不应低于UDP超时（默认为30）
    -udptimeout int
        设置UDP超时，应大于TCP超时（默认为150）
    -debug  
        启用Debug，显示调试信息
    -h 显示帮助
    -l string 
        只能在Local模式下使用，用于设置Socks5监听地址 [::]:10805 (默认 "[::]:10805")
    -lower
        使用较低安全性的加密方法（AES-128-GCM）而不是AES-256-GCM，此选项将影响所有密码的加密。使用多台服务器时，请注意，无法自定义每个服务器使用的密码加密模式
    -gzip
        开启Gzip压缩数据以节省流量，这可能增加机器的负担并降低流量响应速度(一般来说可以忽略不计的延迟增加，但是不可忽略的CPU占用增加)
    -test
        在测试模式下，将在一台计算机上运行服务器和客户端

关于程序原理：

简单的指令包的结构
+---------------+--------------+--------------+----------+----------+
| Session ID | Control Code | Address Type | DST.ADDR | DST.PORT |
+---------------+--------------+--------------+----------+----------+
| 16 byte | 1 byte | 1 byte | Variable | 2 byte |
+---------------+--------------+--------------+----------+----------+
Session 由客户端生成的唯一随机数,16 字节，由客户端定义，作为会话 ID 使用
Control Code 与 socks5 相同的控制代码
Address Type 与 socks5 相同的地址类型
DST.ADDR 与 socks5 相同的地址
DST.PORT 与 socks5 相同的端口




这是一个数据帧
在加密数据前面加上随机填充的内容以混淆，随机填充内容随机长度（0-255），由数据包第一个字节决定，结构
 +--------------------+-------------+----------------+----------+---------+
 | Random data length | Random Data | payload length | playload |  CRC32  |
 +--------------------+-------------+----------------+----------+---------+
 |       1 byte       |   variable  |     4 byte     | variable |  4 byte |
 +--------------------+-------------+----------------+----------+---------+

 末尾的CRC32为对前面所有数据的CRC32校验值

Server 会收集满一整个数据帧后进行处理,验证失败会直接断开连接，而对于重放使用


抗重放：
客户端发起连接服务器的首个数据包，由秘钥加时间戳的MD5通过 HASH 函数共同通过
AES - GCM 加密方式加密，每个包都有其独特的包 ID，也就是包头的 16 byte 随机数，允许服务器和客户端的时间差为正负两秒之内

自己写了一个 FIFO 的链表，服务器首次收到连接都会校验包 ID 是否在这个链表里，在这个链表里就证明一分钟内曾使用过这个 ID
为了防止数组会越来越大，占用内存不说，每次接受连接时遍历数组会越来越困难，开个 goruntime 检查每个 包 ID 的生存周期，过期的包会被删除
若是超过5秒的话就删除，此时因为存在首包使用时间戳加密的缘故，正负两秒以外的包将不会被服务器接受，所以这个方案可行

采用 FIFO 链表的原因是，这样检测包生存周期的 func，仅需要检查首个数据的生存周期，如果它没过期，那后续包不可能过期，
如果其过期那就删除后检测下一个包（此时其成为新的“首个数据”）,还是过期的话继续删除，重复这一操作，
这样的话就不需要检查生存周期时遍历整个链表了，但是检查这个数据是否已存在于链表中，依然需要遍历整个链表

应对本地echo重放攻击：
    Client的加密数据包有自己的标识，用GCM加密方式的A的ADD Data部分标识0XFF,0XFF
    Server的加密数据包有自己的标识，用GCM加密方式的A的ADD Data部分标识0XFC,0XFF

应对交换顺序的TCP包重放:
    只能用增加包ID来解决，包ID从零开始递增，用uint32，4byte表示

ADD DAT整个部分用MD5加密获取HASH

仍然存在的bug：
    被恶意的交换数据包顺序客户端与服务端也不能分辨出来。
    可能被大规模的流量分析发现特征，毕竟这是个未知的加密流量，所以我打算伪装成FTP，然后客户端和服务端握手完全遵守FTP的规范，这样就不会被发现里，就算流量被Dump，那也是以“文件”的形式被Dump下来

尚未实现的目标：
    1: 伪装FTP(但是似乎不是很好的选择，而伪装http、https不如用造好的轮子，
    2: 为加密数据增加包ID，用于防止MITM的交换包顺序重放

更新日志
V1.0.0:
    完成大体框架，跑得起来的程度
V1.1.0:
    重大更新，重新精炼了代码，加入了抗重放的功能
V1.2.0:
    修bug，增加了服务器负载均衡的功能，支持多服务器，支持选择AES GCM加密方式的密码位数（128位，256位）
V1.2.2:
    修复了负载均衡的bug，改善了抗重放的逻辑，安全性提升
V1.2.4：
    加入Gzip压缩数据，是否真的有用呢？还是单纯在耗费CPU性能呢？？ 调整默认允许的数据包收发两段时间差值到10秒，把nonceGC运行间隔设置成15秒
V1.2.5:
    更改使用的官方gzip库为第三方的github.com/klauspost/pgzip库，因为这个库大幅优化了gzip的压缩效率，go官方gzip实现相比之下太慢力！
V1.2.6:
    删除gzip压缩方法，无论使用哪个库，都会使CPU占用率大幅提升，而速度大幅降低，在我的平台上，开启gzip后CPU占用率从4%上升到24%，但是速度却从240Mbps降到了30Mbps，匪夷所思。
V1.2.7:
    更新了更多的抗中间人，抗协议分析的过程，吸收了很多前人的经验，更改了加密数据承载的格式，增加了对逐字节重放的防御，优化了对重放的判断逻辑，话说部署测试时真的收到重放数据包了诶